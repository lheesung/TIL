# CHAPTER 01

# 💁‍♂️ 운영체제의 개요

##  운영체제

**운영체제**는 일반 컴퓨터, 노트북, 스마트폰의 전원을 켜면 가장 먼저 만나는 소프트웨어다. 운영체제의 정의는 **응용 프로그램이나 사용자에게 컴퓨터 자원을 사용할 수 있 수 있는 인터페이스를 제공하고 그 결과를 돌려주는 시스템을 말한다. 또 이는 사용자에게 모든 컴퓨터 자원을 숨기고, 정해진 방법으로만 컴퓨터 자원을 사용할 수 있도록 제한한다.**

## 🪨 운영체제의 역할과 목표

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/99fe1a36-b09d-4c5a-b4de-63768123b522/Untitled.png)

### 👨‍⚖️ 운영체제의 역할

1. 자원관리 : 
    
    사용자가 원활히 작업할 수 있도록 자원을 응용 프로그램에 적절히 분배. 
    
    → 적절한 시점에 자원을 회수해 다른곳에 다시 분배함.
    
2. 자원보호 :
    
    비정상적인 작업으로 부터 자원을 보호함.
    
3. 하드웨어 인터페이스 제공 : 
    
    사용자가 복잡하지 않게 다양한 장치를 쓸 수 있도록 지원. 
    
    다양한 하드웨어를 일괄된 방법으로 사용할 수 있도록 지원.
    
4. 사용자 인터페이스 제공
    
    사용자가 운영체제를 편리하게 사용할 수 있게 지원.(ex.GUI)
    

> 💡 관보하사
> 

### 🥷 운영체제의 목표

1. 효율성:
    
    자원을 효율적으로 관리하는 것. → **최소한의 자원으로 최대한의 작업.**
    
2. 안정성: 
    
    **작업을 안정적으로 처리하는 것.**
    
3. 확장성:
    
    다양한 시스템 자원을 컴퓨터에 **추가/제거가 편리한 것.**
    
4. 편리성 : 
    
    사용자가 **작업을 편리하게 할 수 있도록 환경을 제공**하는 것.
    

> 💡 효안확편
> 

## 🦴 운영체제의 역사

| 구분 | 시기 | 주요 기술 | 특징 |
| --- | --- | --- | --- |
| 0기 | 1940 년대 |  | 진공관( 0, 1 사용) |
| 1기 | 1950 년대 | 카드 리더, https://ko.wikipedia.org/wiki/%EB%9D%BC%EC%9D%B8_%ED%94%84%EB%A6%B0%ED%84%B0 | 일괄 작업 시스템   OS 등장 |
| 2기 | 1960 년대 초 | 키보드, 모니터 | 대화형 시스템 |
| 3기  | 1960 년대 말 | C 언어 | 다중 프로그래밍 기술 개발, 시분할 시스템 개발 |
| 4기 | 1970 년대 | PC | 개인용 컴퓨터 등장     분산 시스템 |
| 5기 | 1990 년대 | 웹 | 클라이언트 / 서버 |
| 6기 | 2000 년대 | 스마트 폰 | P2P( 메신저, 파일공유), 그리드 컴퓨팅, 클라우드 컴퓨팅, 사물 인터넷 |

# 🕳️ 커널

**커널**은 프로세스, 메모리, 저장장치 관리와 같은 **운영체제의 핵심적인 기능을 모아둔 것을 말한다.**

## 🏘️ 인터페이스

**인터페이스**는 커널에 **사용자의 명령을 전달**하고 **실행 결과를 사용자에게 알려주는 역할**을 한다.

그래픽을 사용한 인터페이스를 **GUI** 라 함.

## 🔔 시스템 호출과 디바이스 드라이버

### 👀 시스템 호출

**시스템 호출**은 커널이 자신을 보호하기 위해 만든 인터페이스다. 

→ 사용자 or 응용 프로그램으로 부터 컴퓨터 자원을 보호 

→ 자원에 직접 접근 차단

### 👀 직접 호출

두 응용 프로그램이 자기 마음에 드는 위치에 데이터를 저장하고 싶음 

→ 다른 사람의 데이터를 지우거나 내 데이터가 다른 사람에 의해 지워질 수 있음.

### 👀 시스템 호출을 위한 접근

커널이 제공하는 **write()** 함수를 사용하여 응용 프로그램이 데이터를 저장해달라고 요청. ****

커널이 데이터를 가져오는 것과 저장을 모두 담당 → 컴퓨터 자원관리 용이

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aebdff35-1da7-49b2-b28f-ce7f618aaf7d/Untitled.png)

### 👀 드라이버

**드라이버**란 커널과 하드웨어의 인터페이스를 담당하는 것이다.

그래픽 카드와 같은 복잡한 하드웨어에게 제작자가 드라이버를 제공 한다.

## 👨‍👩‍👦‍👦 커널의 구성

### 📑 커널이 하는 일

| 일 | 설명 |
| --- | --- |
| 프로세스 관리 | 프로세스에 CPU를 배분 및 작업에 필요한 제반환경 제공 |
| 메모리 관리 | 프로세스에 작업 공간을 배치, 가상공간 제공(실제 메모리보다 큼) |
| 파일 시스템 관리 | 데이터 저장 및 접근이 가능한 인터페이스 제공 |
| 입출력 관리 | 필요한 입출력 서비스 제공 |
| 프로세스 간 통신 관리 | 공동작업을 위한 프로세스 간 통신환경 지원 |

> 💡 프메파입통
> 

### 🥫 단일형 구조 커널

단일형 구조의 **커널은 초창기 운영체제의 구조**다. 커널의 핵심적인 기능을 구현하는 **모듈들이 하나로 구성되있는 것**이 특징이다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/be81a5c3-02f9-46fe-9062-322af50cf0d4/Untitled.png)

### 👍 장점

모듈 간 통신 비용 절감. → 효율적 운영 가능

### 👎 단점

버그, 오류 처리 힘듦 → 왜? 하나로 묶어놔서

하나의 결함이 시스템 전체로 확산할 수 있음 → 왜? 하나로 묶어놔서

다양한 환경의 시스템에 적용하기 어려움.

요즘 운영체제는 복잡 → 단일형으로 구현하기 어려움.

### 🏢 계층형 구조 커널

계층형 구조 커널은 **비슷한 기능을 가진 모듈을 묶어 하나의 계층**으로 만들고 계층 간의 통신을 통해 운영체제를 구현하는 방식이다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d73c23d6-a172-4c93-8203-6216b1c9869a/Untitled.png)

### 💽 마이크로 구조 커널

마이크로 구조 커널이란 [커널이 하는 일](https://www.notion.so/ec14384034b74c09b91e71c39252e911) 등 기본적인 기능만 제공한다. 커널의 **각 모듈은 세분화**되어있고 프로세스 간 통신을 통해 모듈끼리 정보를 공유한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/de581706-3858-48ea-82c7-2ee32e6b3984/Untitled.png)

## 🖲️ 가상머신

가상머신은 운영체제와 응용 프로그램 사이에서 작동하는 프로그램으로 이를 설치하면 **응용 프로그램이 모두 같은 환경에서 작동하는 것 처럼 보인다.** 

> 자바는 유닉스와 윈도우에서 작동하는 다양한 가상머신을 만들어 배포하는데 이를 자바 가상머신(JVM)이라고 함
> 

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2f12268e-6c91-436e-8b8d-e883c323e506/Untitled.png)

# CHAPTER 02

# 🖥️ 컴퓨터의 구조와 성능향상

### ⚙️ 컴퓨터의 구성

컴퓨터의 구성에는 필수장치와 주변 장치로 크게 나뉜다.

> 필수장치 : 중앙처리장치, 메인 메모리
> 

> 주변장치 : 입출력장치, 저장장치
> 

### 🤖 하드웨어의 구성

- 🀄️ 용어통일
    
    메인메모리 → 메모리
    
    보조저장장치 → 저장장치
    
    중앙처리장치 → CPU
    
- 👯‍♂️ CPU와 메모리
    - CPU : 명령어를 해석 및 실행. 뇌라고 생각하셈
    - 메모리 : 프로그램과 데이터 저장하는 곳. 바이트 단위로 분할. 분할된 공간마다주소로 구분함.
- 입출력 장치
    
    입출력 장치는 컴퓨터와 외부 기기 간에 데이터를 주고받는 역할을 함. 대표적인 입출력 장치로는 마우스, 키보드, 모니터, 프린터, 스캐너, 스피커 등이 있음.
    
- 저장장치
    - 저장장치 : 컴퓨터가 사용하는 데이터와 프로그램을 저장하는 장치. 하드디스크, SSD 등이 있음.

- 메인보드
    
    메인보드는 CPU 와 메모리 등 다양한 부품을 연결하는 큰 판이다. 버스가 지나다니는 통로이기도 함.
    
- **‼️ 폰노이만 구조**
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/14d7af83-17e3-46d0-b580-e984d1805497/Untitled.png)
    

### 🚗 CPU 구성과 동작

# CHAPTER 03

# 🏗️ 프로세스의 개요

## 👷‍♂️ 프로세스란?

프로세스란 실행을 위해 메모리에 올라온 동적 상태를 말한다.

> cf 프로그램?) 저장장치에 저장되어 있는 정적인 상태
> 

### 🐸 프로세스와 프로그램

프로그램이 프로세스가 된다. → OS 로부터 제어 블록을 얻는다.

프로세스가 종료된다. → 해당 프로세스 제어 블록이 페기된다.

> 프로세스 = 프로그램 + 프로세스 제어블록
> 

### 🌱 프로세스의 네 가지 상태

### 👀 생성상태

프로세스가 메모리에 올라와 실행 준비를 완료한 상태

### 👀 준비상태

생성된 프로세스가 CPU 를 얻을 때까지 기다리는 상태

### 👀 실행상태

준비 상태에 있는 프로세스 중 하나가 작업을 얻어 수행 중인 상태

### 👀 완료상태

실행상태의 프로세스가 주어진 식업동안 작업을 마치고 들어가는 상태

(프로세스 제어블록이 삭제된 상태임.)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6a1863c1-6067-491d-b056-ca1f304c776f/Untitled.png)

### 💡디스패치

준비상태의 프로세스 중 하나를 실행상투로 바꾸는 CPU 스케쥴러의 직업

### 💡타임아웃

주어진 타임 슬라이스 동안 작업을 못끝내면 다시 준비상태로 돌아가는 것.

### 🌳 프로세스의 다섯 가지 상태

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/024d2b5c-af56-4b40-afeb-207edba41c9a/Untitled.png)

| 상태 | 설명 | 작업 |
| --- | --- | --- |
| 생성 | 프로그램을 메모리에서 가져와 준비가 완료된 상태 | 메모리할당, 프로세스 제어 블록 |
| 준비 | 프로세스가 자기 차례를 기다리는 상태 | difpatch(PID): 준비 → 실행 |
| 실행 | 프로세스가 타임 슬라CPU 를 사용하는 상태 | timeout(PID), exit(PID), block(PID) |
| 대기 | 실행상태에 있는 프로세스가 입출력 요청 → 완료될 때 까지 기다리는 상태 | wakeup(PID) → 해당 프로세스의 제어블록이 준비 상태로 |
| 완료 | 프로세스가 종료된 상태. 쓰던 모든 데이터 정리. exit 과 abort(비정상종료) 포함 | 메모리삭제, 프로세스 제어블록 삭제 |

### ‼️ 프로세스 제어 블록(PCB)

프로세스 제어 블록은 프로세스를 실행할 때 필요한 중요한 정보를 보관하는 자료구조다. 프로세스는 고유의 PCB를 가지고, 이는 프로세스 생성 시 함께 만들어지고 프로세스의 실행이 끝나면 폐기된다.

### 구성

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5e7f982f-84a0-416e-b01b-4daf5d085250/Untitled.png)

포인터 : 준비상태 & 대기상태의 큐 구현 시 사용

프로세스 상태 : 프로세스의 현재 상태

프로세스 구분자 : 여러 프로세스를 구현하기 위한 구분자 → pid

프로그램 카운터 : 다음에 실행될 명령어 위치를 가르키는 프로그램 카운터 값.

프로세스 우선순위 : 프로세스 실행 순서를 결정

각종 레지스터 정보 : 프로세스 실행 중 사용하던 레지스터 값

# CHAPTER 04

# 🧭 CPU 스케줄링

# 👨‍🔧 CPU 스케줄러

**CPU 스케줄러** 란 여러 프로세스의 상황을 고려하여 CPU와 시스템 자원의 배정을 결정하는 것을 말한다.

## 👨‍🎓 고수준 스케줄링( 장기 ‘’ , 승인 ‘’)

**고수준 스케줄링**은 **시스템 내의 전체 작업 수를 조절하는 것**을 말한다. 이는 **어떤 작업을 시스템이 수락 or 거부 할지 결정한다.** 고수준 스케줄링은 시스템 내에서 동시에 실행 가능한 프로세스의 총 개수가 정해진다.

## 🧑‍💼 저수준 스케줄링(단기 ‘’)

**저수준 스케줄링**은 어느 프로세스에 **CPU를 할당하고, 대기 상태로 보낼지** 등을 결정하는 것을 말한다. 아주 짧은 시간안에 일어난다.

## 👨‍💼 중간 수준 스케줄링

**중지와 활성화**로 전체 시스템의 활성화된 프로세스 수를 조절하여 과부화를 막는다. 일부 프로세스를 중지 상태로 옮겨 나머지 프로세스가 정상적으로 작동하도록 지원한다.(저수준 스케줄링이 잘 이루어 지도록 완충하는 역할을 하기도 함.)

## 💊 고수준, 저수준, 중간 수준 스케줄링의 특징

| 고수준 스케줄링 | 전체 시스템의 과부화를 고려하여 작업의 시작 여부를 판단함. |
| --- | --- |
| 중간 수준 스케줄링 | 시스템의 과부화가 걸리면 이미 활성화된 프로세스 중
일부를 보류 상태로 보냄. |
| 저수준 스케줄링 | 실제 작업을 수행함. |

## 🧑‍🎨 도식화

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a08868a9-c4c7-4b2a-8a00-438dc0b1771a/Untitled.png)

## 💂 CPU 스케줄링의 목적

### 👀 공평성

모든 프로세스가 자원을 공평히 배정받아야 함. 자원 배정 과정에서 특정 프로세스가 배제되어서는 안 됨.

### 👀 효율성

시스템 자원이 유휴 시간* 없이 사용되도록 스케줄링을 함. 유휴 자원을 사용하려는 프로세스에게 우선권을 부여함.

### 👀 안정성

우선순위를 사용하여 중요 프로세스가 먼저 작동하도록 배정함 → 시스템의 자원을 점유하거나 파괴하려는 프로세스로 부터 자원을 보호.

### 👀 확장성

프로세스가 증가하더라도 시스템이 안정적으로 작동하게 조치해야함. 시스템 자원이 늘어나는 경우 확장성이 시스템에 반영되게 해야함.

### 👀 반응시간 보장

응답이 없는 경우 시스템이 멈춘것으로 가정 → 시스템은 적절한 시간 내에 프로세스의 요구에 반응해야 함.

### 👀 무한 연기 방지

특정 프로세스의 작업이 무한히 연기되어서는 안됨.

### 💡유휴시간?

> 유휴 시간: 작업자 또는 기계가 작업에 필요한 여건이 갖추어 지지 않아서 생산에 직접 사용되지 않는 시간
> 

## 🦸‍♂️ 선점형 스케줄링

**선점형 스케줄링**이란 OS가 필요하다고 판단하면 **실행 상태에 있는 프로세스의 작업을 중단시키고 새로운 작업을 시작할 수 있는 방식**이다. 이는 하나의 프로세스가 CPU를 독점할 수 없기에 빠른 응답 시간을 요구하는 대화형 시스템이나 시분할 시스템에 적합하다. (대부분의 저수준 스케줄러가 이 방식을 사용)

## 🦹 비선점형 스케줄링

비선점형 스케줄링은 어떤 프로세스가 실행 상태에 들어가 CPU를 사용하면 그 프로세스가 종료되거나 자발적으로 대기 상태에 들어가기 전까지 계속 실행되는 방식을 말한다. 이 방식은 선점형 스케줄링보다 스케줄러의 작업량이 적고 문맥 교확에 의한 낭비 또한 적다. 하지만 CPU 사용 시간이 긴 프로세스 때문에 CPU 사용 시간이 짧은 여러 프로세스가 오랫동안 기다리게 되기 때문에 전체적인 시스템 처리율은 떨어지는 편이다.

## 🦸‍♂️선점형 스케줄링 VS 🦹비선점형 스케줄링

| 구분 | 선점형 스케줄링 | 비선점형 스케줄링 |
| --- | --- | --- |
| 작업 방식 | 실행 상태에 있는 작업을 중단시키고 새 작업 가능 | 실행 상태의 작업이 다 끝난 뒤 새로운 작업 가능 |
| 장점 | 프로세스가 CPU 독점 불가능 → 대화형 or 시분할 시스템에 적합 | CPU 작업량이 적음. 문맥 교환의 오버헤드가 적음 |
| 단점 | 문맥 교환의 오버헤드가 많음 | 기다리는 프로세스가 많아 처리율이 떨어짐. |
| 사용용도 | 시분할 방식 스케줄러 | 일괄 작업 방식 스케줄러 |
| 중요도 | 높음 | 낮음 |

### 💡 오버헤드?

오버헤드란 **프로그램의 실행흐름에서 나타나는 현상** 중 하나로 예를 들어 , 프로그램의 실행흐름 도중에 동떨어진 위치의 코드를 실행시켜야 할 때 , 추가적으로 시간,메모리,자원이 사용되는 현상이다.

# 👮‍♂️ 프로세스 우선순위

우선순위는 커널 프로세스 > 일반프로세스. 시스템에서 우선순위가 높은 프로세스가 CPU 를 먼저, 오래 차지한다.

## 👷‍♂️ CPU 집중 프로세스

수학연산과 같은 CPU 를 많이 사용하는 프로세스. CPU 버스트가 많음.

### 💡 CPU 버스트?

프로세스나 스레드가 실행되기 전에 일시적으로 CPU 자원을 즉시 사용할 수 있는 상태

## 🧑‍🏭 입출력 집중 프로세스

저장장치에 데이터를 복사하는 일과 같이 입출력을 많이 사용하는 프로세스. 입출력 버스트가 많음.

### 💡 입출력 버스트?

입출력 버스트는 CPU가 입출력 작업을 수행하기 위해 장치와 통신하는 동안 일시적으로 CPU를   사용할 수 없는 상태.

## 🧑‍🚒 우선배정

스케줄링을 할 때 입출력 집중 프로세스의 우선순위를 CPU     집중 프로세스보다 높이면 시스템 효율이 향상한다.

## 🧑‍✈️ 전면 프로세스

**전면 프로세스**란 GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓인 프로세스다. 이는 현재 입출력을 사용하는 프로세스다.    (사용자와 상호작용이 가능하기에 상호작용 프로세스라고도 함)

## 🧑‍💻 후면 프로세스

**후면 프로세스**란 사용자와 상호작용이 없는 프로세스다. 전면  프로세스의 우선순위가 후면 프로레스보다 높다.                            (사용자의 입력 없이 작동하기에 일괄작업 프로세스라고도 함)

## 👀 CPU 스케줄링 시 고려사항

| 우선순위 높음 | 우선순위 낮음 |
| --- | --- |
| 커널 프로세스 | 일반 프로세스 |
| 전면 프로세스 | 후면 프로세스 |
| 대화형 프로세스 | 일괄 처리 프로세스 |
| 입출력 집중 프로세스 | CPU 집중 프로세스 |

# 🚅 다중 큐

**다중 큐**는 **여러 개의 큐가 하나의 시스템에서 동시에 동작하도록 설계된 데이터** 구조다.

## 👀 주변 상태의 다중 큐

프로세스는 준비 상태에 들어올 때마다 자신의 우선순위에 해당하는 **큐의 마지막에 삽입한다**.

### 💡 프로세스의 우선순위를 배정하는 방식

- **👀 고정 우선순위 방식**
    - OS가 프로세스의 우선순위를 부여 → 프로세스가 끝날 때 까지 바뀌지 않음.
    - 프로세스가 작업하는 동안 우선순위 변화 X → 구현은 용이하지만 시스템의 변화에 대응하기 어려움.
- 👀 변동 우선순위 방식
    - 프로세스 생성시 부여받은 우선순위가 프로세스 작업 도중에 변하는 방식
    - 구현하기 어렵지만 시스템의 효율성을 높일 수 있음.

## 👀 대기 상태의 다중 큐

시스템의 효율을 높이기 위해 대기 상태에서는 같은 입출력을 요구하는 프로세스끼리 모아둠.

## 🗣️ 다중 큐 비교

| 준비 큐 | 한 번에 하나의 프로세스를 꺼내 CPU를 할당함. |
| --- | --- |
| 대기 큐 | 여러 프로세스 제어 블록을 한번에 꺼내 준비상태로 옮김. |
|  | 대기 큐에서 동시에 끝나는 입터럽트를 처리하기 위해 인터럽트 벡터 라는 자료구조를 사용. |

### 💡 인터럽트?

인터럽트는 컴퓨터에서 발생하는 외부적인 이벤트로, 현재 실행 중인 프로그램의 흐름을 일시적으로 멈추고 다른 처리를 수행하도록 강제로 전환하는 기술적인 방법이다.

# 🧑‍🌾 스케줄링 알고리즘의 선택 기준

- CPU 사용률
    - 전체 시스템의 동작 시간 중 CPU 사용된 시간을 측정하는 방법
    - 가장 이상적인 수치는 100%지만 실제로 90%에도 미치지 못함
- 처리량
    - 단위 시간당 작업을 마친 프로세스의 수 ←얘가 클수록 좋은 알고리즘

# 🧑‍🌾 스케줄링 알고리즘의 평가 기준

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dd83ed65-1c79-4079-b7a9-d1f44e7aef7e/Untitled.png)

👀 대기시간 : 프로세스가 생성된 후 실행되기 전까지 대기하는 시간

👀 응답 시간 : 첫 작업을 시작한 후 첫 번째 출력(반응)이 나오기 까지의 시간

👀 실행 시간 : 프로세스 작업이 시잔된 후 종료되기까지의 시간

👀 반환 시간 : 대기 시간을 포함하여 실행이 종료될 때까지의 시

### 💡 평균 대기시간

(모든 프로세스의 대기시간의 합) / 프로세스의 수

# 🧑‍🔬 FCFS 스케줄링(First-Come-First-Serve)

FCFS스케줄링은 **준비 큐에 도착한 순서대로 CPU를 할당**하는 비선점형 방식이다. 한 번 실행되면 그 프로세스가 끝나야만 다음 프로세스를 실행할 수 있다. 이는 큐가 하나뿐이기 때문에 모든 프로세스는 우선순위가 동일하다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c1f08160-1868-4774-9e7a-9dd5fb094da3/Untitled.png)

## 🧮 FCFS 스케줄링 성능 구하기

| 도착 순서 | 도착 시간 | 작업 시간 |
| --- | --- | --- |
| P1 | 0 | 30 |
| P2 | 3 | 18 |
| P3 | 6 | 9 |

→ 평균 대기시간: (0 + 27+ 42) / 3 = 23m/s

## 🔍FCFS 스케줄링의 평가

처리 시간이 긴 프로세스가 CPU 차지 → 그 프로세스가 끝날때 까지 기다림 → 시스템 효율성 ⬇️                  현재 작업 중인 프로세스가 입출력 작업을 요청 → CPU가 노는 시간이 많아짐 → 작업 효율 ⬇️

# 🧑‍🚒 SJF 스케줄링(Shortest-Job-First)

SJF 스케줄링은 준비 큐에 있는 **프로세스 중에서 실행 시간이 가장 짧은 작업부터 CPU를 할당**하는 비선점형 방식이다. 콘보이 효과를 완화하여 시스템의 효율성을 높인다.

### 💡 콘보이 효과?

네트워크 패킷 전송에 대한 현상을 말한다. 데이터 패킷은 일렬로 나열되어 전송되며, 패킷을 전송하는 장치들 간의 지연 시간이 줄어듦으로써 전체적인 효율성이 향상된다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/62edeb8e-e952-4bb0-b8a1-d991370858c0/Untitled.png)

## 🧮 SJF 성능 구하기

| 도착 순서 | 도착 시간 | 작업 시간 |
| --- | --- | --- |
| P1 | 0 | 30 |
| P2 | 3 | 18 |
| P3 | 6 | 9 |

→ 평균 대기시간: (0 + 24+ 36) / 3 = 20m/s

## 🔍 SJF 스케줄링의 평가

운영체제가 프로세스의 종료 시간을 정확히 예측하기 어려움. 작업 시간이 길다는 이유만으로 계속 뒤로 밀려 공평성이 어긋남**(아사현상)**.

### 💊 에이징

아사 현상을 완화시킬 수 있는 방법으로 프로세스가 양보할 수 있는 상한선을 정하는 방식이다.                프로세스가 자신의 순서를 양보할 때마다 나이를 한 살씩 먹어 최대 몇 살까지 양보하도록 정한 것    이다.

# 🏢 HRN 스케줄링(Highest-Response-Ratio-Next)

HRN 스케줄링은 SJF 스케줄링에서 발생할 수 있는 아사 현상을 해결하기 위해 만들어진 비선점형
알고리즘이다. 서비스를 받기 위해 기다린 시간과 CPU 사용 시간을 고려하여 스케줄링을 하는 방식이다. 이는 프로세스의 우선순위를 정하는 기준이 된다.

### 💡 우선순위

(대기시간 + CPU 사용시간) / CPU 사용시간 = 우선순위

## 🧮 HRN 성능 구하기

| 도착 순서 | 도착 시간 | 작업 시간 |
| --- | --- | --- |
| P1 | 0 | 30 |
| P2 | 3 | 18 |
| P3 | 6 | 9 |

→ 평균 대기시간: (0 + 24 + 36) / 3 = 20m/s

## 🔍 HRN 스케줄링의 평가

실행 시간이 짧은 프로세스의 우선순위를 높게 설정하면서도 대기 시간을 고려하여 아사 현상을     완화시킨다. 대기 시간이 긴 프로세스의 우선순 위를 높임으로써 CPU를 할당받을 확률을 높힌다.
하지만 여전히 공평성이 위배되어 많이 사용되지 않는다.

# 🏹 라운드 로빈 스케줄링(Round Robin)

한 프로세스가 할당받은 시간(타임 슬라이스) 동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식이다.선점형 알고리즘 중 가장 단순하고 대표적인 방식임. 프로세스들이 작업을 완료할 때까지 계속 순환하면서 실행한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/552fff37-c87d-41a4-a82c-86db7bea6ab6/Untitled.png)

## 🧮 RR 성능 구하기

| 도착 순서 | 도착 시간 | 작업 시간 |
| --- | --- | --- |
| P1 | 0 | 30 |
| P2 | 3 | 18 |
| P3 | 6 | 9 |

→ 평균 대기시간: 0(P1)+7(P2)+14(P3)+19(P1)+19(P2)+8(P1)= 67 / 3 = 22.23m/s

## ⏰ 타임 슬라이스

- 타임 슬라이스의 크기와 문맥
    - 라운드 로빈 스케줄링이 효과적으로 작동하려면 문맥 교환에 따른 추가 시간을 고려하여   타임 슬라이스를 적절히 설정해야 한다.
- 타임슬라이스가 큰 경우
    - 하나의 작업이 끝난 뒤 다음 작업이 시작되는 것 처럼 보여 FCFS 과 똑같다.
- 타임슬라이스가 작은 경우
    - 문맥 교환이 너무 자주 일어남 → 문맥 교환에 걸리는 시간 > 실제 작업시간 → 문맥교환에 시간을 낭비하여 실제 작업을 못하는 문제가 생김.

따라서 타임 슬라이스는 되도록 작게 설정하되 문맥 교환에 걸리는 시간을 고려하여 적당한 크기로 하는 것이 중요하다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a90a0314-cfbd-4c48-a5fe-3e294d6f0a33/Untitled.png)

# 🚄 SRT(Shortest Remaining Time)

기본적으로 라운드 로빈 스케줄링을 사용. 하지만 CPU를 할당받을 프로세스를 선택
할 때 남아 있는 작업 시간이 가장 적은 프로세스를 선택함.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3ec46c0b-1faf-4633-94b7-d99ada5429e3/Untitled.png)

## 🧮 SRT 성능 구하기

| 도착 순서 | 도착 시간 | 작업 시간 |
| --- | --- | --- |
| P1 | 0 | 30 |
| P2 | 3 | 18 |
| P3 | 6 | 9 |

→ 평균 대기시간: 0(P1)+4(P3)+16(P2)+27(P1)=47 / 3 = 15.66m/s

## 🔍 SRT 스케줄링의 평가

현재 실행 중인 프로세스와 큐에 있는 프로세스의 남은 시간을 주기적으로 계산하고, 남은 시간이   더 적은 프로세스와 문맥 교환을 해야 하므로 SJF 스케줄링에는 없는 작업이 추가됨. **운영체제가 프로세스의 종료 시간을 예측하기 어렵고 아사 현상이 일어나기 때문에 잘 사용하지 않음.**

# 👮 우선순위 스케줄링

우선순위 스케줄링은 프로세스의 중요도에 따른 우선순위를 반영한 스케줄링 알고리즘이다.

## 🧑‍⚖️ 우선순위 적용

우선순위는 비선점형 방식과 선점형 방식 모두 사용할 수 있다.

- (비선점형) SJF 스케줄링 : 작업 시간이 짧은 프로세스에 높은 우선순위를 부여
- (비선점형) HRN 스케줄링 : 작업 시간이 짧거나 대기 시간이 긴 프로세스에 높은 우선순위를 부여
- (선점형) SRT 스케줄링 : 남은 시간이 짧은 프로세스에 높은 우선순위를 부여

## 👨‍🔬 우선순위 알고리즘

- 고정 우선순위 알고리즘
    - 한 번 우선순위를 부여 → 종료까지 우선순위 고정
    - 단순히 구현 가능. but 시시각각 변하는 시스템의 상황 반영 불가 → 효율⬇️
- 변동 우선순위 알고리즘
    - 일정 시간마다 우선순위가 변함.
    - 구현하기 어렵지만 시스템의 상황을 반영 → 효율⬆️

## 🔍 우선순위 스케줄링의 평가

준비 큐에 있는 프로세스의 순서를 무시하고 우선순위가 높은 프로세스에 먼저 CPU를 할당하므로 공평성을 위배하고 아사 현상을 일으킴. 

준비 큐에 있는 프로세스의 순서를 무시하고 프로세스의 우선순위를 매번 바꿔야 하기 때문에  오버헤드가 발생하여 시스템의 효율성을 떨어뜨림.

# 🧑‍🔧 다단계 큐 스케줄링

다단계 큐는 우선순위에 따라 준비 큐를 여러개 준비하는 방식이다. 

프로세스는 운영체제로부터 부여받은 우선순위에 따라 해당 우선순위의 큐에 삽입함.                           우선순위는 고정형 우선순위를 사용함.
상단의 큐에 있는 모든 프로세스의 작업이 끝나야 다음 우선순위 큐의 작업이 시작됨.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7cc28e82-3cd5-4908-bd57-d3c93302a5d9/Untitled.png)

# ⚙️ 다단계 피드백 큐 스케줄링

- 프로세스가 CPU를 한 번씩 할당받아 실행될 때마다 프로세스의 우선순위를 낮춤으로써, 다단계 큐에서 우선순위가 낮은 프로세스의 실행이 연기되는 문제를 완화함.
- 우선순위가 낮아진다고 할지라도 커널 프로세스가 일반 프로세스의 큐에 삽입되지는 않음.
- 우선순위에 따라 타임 슬라이스의 크기가 다름.
- 우선순위가 낮아질수록 CPU를 얻을 확률이 적어짐.→ 한번 CPU를 잡을 때 많이 작업하라고  낮은 우선순위의 타임 슬라이스를 크게 함.
- 마지막 큐에 있는(우선순위가 가장 낮은) 프로세스는 무한대의 타임 슬라이스를 얻음. 마지막 큐는 들어온 순서대로 작업을 마치는 FCFS 스케줄링 방식으로 동작

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1cebcba3-d927-4846-9f7a-bfb4dbf8a01d/Untitled.png)

# 🦖 인터럽트

## 🚪 폴링

폴링이란 입출력을 요청하면 운영체제가 주기적으로 입출력장치를 직접 확인해서 처리하는 방식이다.

## 🦕 인터럽트

인터럽트란 이벤트 드리븐 방식과 마찬가지로 입출력을 요청하고 입출력이 완료되면 이벤트를
발생시켜 알림.

### 👀  동기적 인터럽트

- 프로세스가 실행 중인 명령어로 인해 발생
- 동기적 인터럽트의 종류
    - 프로그램상의 문제 때문에 발생하는 인터럽트
    - 컴퓨터 작업자가 의도적으로 프로세스를 중단하기 위해 발생시킨 인터럽트
    - 입출력장치와 같은 주변 장치의 조작에 의한 인터럽트
    - 산술 연산 중 발생하는 인터럽트

### 👀 비동기적 인터럽트

- 하드디스크 읽기 오류, 메모리 불량과 같은 하드웨어적인 오류로 발생
- 사용자가 직접 조종하는 키보드 인터럽트, 마우스 인터럽트 등이 있음
- 

### ⚙️ 인터럽트 처리과정

1. 인터럽트가 발생하면 현재 실행 중인 프로세스는 정지상태가 됨. 재시작 하기 위해 현제 프로세스 관련 정보를 임시 저장.
2. 인터럽트 컨트롤러가 실행되어 인터럽트의 처리 순서를 결정
3. 먼저 처리할 인터럽트가 결정되면 인터럽트 벡터에 등록된 인터럽트 핸들러가 실행
4. 인터럽트 벡터에 연결된 핸들러가 인터럽트 처리 끝→일시정지된 프로세스가 다시 실행 or 정지

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bbac9481-8c13-494c-8b88-8e13e6c89e13/Untitled.png)

### 🎛️ 인터럽트 모드

👀 커널모드 : OS 와 관련된 커널 프로세스가 실행되는 상태

👀사용자 모드 : 사용자 프로세스가 실행되는 상태

👀이중모드 : OS가 커널 모드와 사용자 모드로 처리하며 일 처리를 하는것. 궁극적 목적→자원보호

### ⚙️ 시스템 호출과 API

사용자 프로세스가 자원에 접근하려면 시스템 호출을 이용해야 함. 사용자 프로세스는 API 가 준비해 둔 다양한 함수를 통하여 시스템 자원에 접근함.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dda7a616-37b5-49b5-9572-1d6f26d564a1/Untitled.png)
